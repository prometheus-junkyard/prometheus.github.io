<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="An open-source monitoring system with a dimensional data model, flexible query language, efficient time series database and modern alerting approach.">
    <meta name="keywords" content="prometheus, monitoring, monitoring system, time series, time series database, alerting, metrics, telemetry">
    <meta name="author" content="Prometheus">

    <link rel="alternate" type="application/atom+xml" title="Prometheus Blog » Feed" href="/blog/feed.xml">

    <link rel="shortcut icon" href="/assets/favicons/favicon.ico">
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/favicons/apple-touch-icon-57x57-cbe16921e26.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/favicons/apple-touch-icon-60x60-cb34684d423.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/favicons/apple-touch-icon-72x72-cb804bd5fae.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/favicons/apple-touch-icon-76x76-cb4a7d77a78.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/favicons/apple-touch-icon-114x114-cbb4144a5d4.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/favicons/apple-touch-icon-120x120-cb24b29faf0.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/favicons/apple-touch-icon-144x144-cb590f03c01.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/favicons/apple-touch-icon-152x152-cbb45d875fa.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon-180x180-cb5da064c37.png">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-32x32-cb6bc898e38.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/assets/favicons/android-chrome-192x192-cbd9b99e56f.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-96x96-cbe466ffcf9.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-16x16-cb02406aa58.png" sizes="16x16">
    <link rel="manifest" href="/assets/favicons/android-chrome-manifest.json">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/assets/favicons/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">

    
    <title>Storage | Prometheus</title>
    

    <!-- Bootstrap core CSS -->
    <link href="/assets/bootstrap-3.3.1/css/bootstrap.min-cb3ab3438f8.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="/css/docs-cb74caebabb.css" rel="stylesheet">
    <link href="/css/routing-tree-editor-cbd4d13cac6.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="/assets/font-awesome-4.2.0/css/font-awesome.min-cbfeda974a7.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Lato:300,300italic,400' rel='stylesheet' type='text/css'>

  </head>

  <body>

  <div class="">
    <nav class="navbar navbar-inverse navbar-static-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"><img src="/assets/prometheus_logo_grey.svg" alt="Prometheus logo"> Prometheus</a>
        </div>
        <div class="collapse navbar-collapse" id="navbar">
          <ul class="nav navbar-nav navbar-right main-nav">
            <li><a href="/docs/introduction/overview/">Docs</a></li>
            <li><a href="/download/">Download</a></li>
            <li><a href="/community/">Community</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="https://github.com/prometheus"><i class="fa fa-github"></i></a></li>
            <li><a href="https://twitter.com/PrometheusIO"><i class="fa fa-twitter"></i></a></li>
          </ul>
        </div>
      </div>
    </nav>
  </div>


<div class="container">
  <div class="row">
    <div class="col-md-3 side-nav-col">
      <ul class="nav navbar-nav side-nav">
        
          <li><span class="nav-header"><i class="fa fa-hand-o-right"></i> <span>Introduction</span></span><ul class="nav "><li><a href="/docs/introduction/overview/">Overview</a></li><li><a href="/docs/introduction/install/">Installing</a></li><li><a href="/docs/introduction/getting_started/">Getting started</a></li><li><a href="/docs/introduction/comparison/">Comparison to alternatives</a></li><li><a href="/docs/introduction/faq/">FAQ</a></li><li><a href="/docs/introduction/roadmap/">Roadmap</a></li><li><a href="/docs/introduction/media/">Media</a></li><li><a href="/docs/introduction/glossary/">Glossary</a></li></ul></li>
        
          <li><span class="nav-header"><i class="fa fa-flask"></i> <span>Concepts</span></span><ul class="nav "><li><a href="/docs/concepts/data_model/">Data model</a></li><li><a href="/docs/concepts/metric_types/">Metric types</a></li><li><a href="/docs/concepts/jobs_instances/">Jobs and instances</a></li></ul></li>
        
          <li><span class="nav-header"><i class="fa fa-search"></i> <span>Querying</span></span><ul class="nav "><li><a href="/docs/querying/basics/">Basics</a></li><li><a href="/docs/querying/operators/">Operators</a></li><li><a href="/docs/querying/functions/">Functions</a></li><li><a href="/docs/querying/examples/">Examples</a></li><li><a href="/docs/querying/rules/">Recording rules</a></li><li><a href="/docs/querying/api/">HTTP API</a></li></ul></li>
        
          <li><span class="nav-header"><i class="fa fa-line-chart"></i> <span>Visualization</span></span><ul class="nav "><li><a href="/docs/visualization/browser/">Expression browser</a></li><li><a href="/docs/visualization/grafana/">Grafana</a></li><li><a href="/docs/visualization/consoles/">Console templates</a></li><li><a href="/docs/visualization/template_examples/">Template examples</a></li><li><a href="/docs/visualization/template_reference/">Template reference</a></li></ul></li>
        
          <li><span class="nav-header"><i class="fa fa-code"></i> <span>Instrumenting</span></span><ul class="nav "><li><a href="/docs/instrumenting/clientlibs/">Client libraries</a></li><li><a href="/docs/instrumenting/writing_clientlibs/">Writing client libraries</a></li><li><a href="/docs/instrumenting/pushing/">Pushing metrics</a></li><li><a href="/docs/instrumenting/exporters/">Exporters and integrations</a></li><li><a href="/docs/instrumenting/writing_exporters/">Writing exporters</a></li><li><a href="/docs/instrumenting/exposition_formats/">Exposition formats</a></li></ul></li>
        
          <li class="active"><span class="nav-header"><i class="fa fa-cog"></i> <span>Operating</span></span><ul class="nav active"><li><a href="/docs/operating/configuration/">Configuration</a></li><li class="active"><a href="/docs/operating/storage/">Storage</a></li><li><a href="/docs/operating/federation/">Federation</a></li><li><a href="/docs/operating/security/">Security</a></li><li><a href="/docs/operating/integrations/">Integrations</a></li></ul></li>
        
          <li><span class="nav-header"><i class="fa fa-bell-o"></i> <span>Alerting</span></span><ul class="nav "><li><a href="/docs/alerting/overview/">Alerting overview</a></li><li><a href="/docs/alerting/alertmanager/">Alertmanager</a></li><li><a href="/docs/alerting/configuration/">Configuration</a></li><li><a href="/docs/alerting/rules/">Alerting rules</a></li><li><a href="/docs/alerting/clients/">Clients</a></li><li><a href="/docs/alerting/notifications/">Notification template reference</a></li><li><a href="/docs/alerting/notification_examples/">Notification template examples</a></li></ul></li>
        
          <li><span class="nav-header"><i class="fa fa-thumbs-o-up"></i> <span>Best practices</span></span><ul class="nav "><li><a href="/docs/practices/naming/">Metric and label naming</a></li><li><a href="/docs/practices/consoles/">Consoles and dashboards</a></li><li><a href="/docs/practices/instrumentation/">Instrumentation</a></li><li><a href="/docs/practices/histograms/">Histograms and summaries</a></li><li><a href="/docs/practices/alerting/">Alerting</a></li><li><a href="/docs/practices/rules/">Recording rules</a></li><li><a href="/docs/practices/pushing/">When to use the Pushgateway</a></li></ul></li>
        
      </ul>
    </div>

    <div class="col-md-9 doc-content">
      <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<h1 id="storage" class="page-header">Storage<a class="header-anchor" href="#storage" name="storage"></a>
</h1>
<div class="toc toc-right"><ul>
<li><a href="#memory-usage">Memory usage
</a></li>
<li><a href="#disk-usage">Disk usage
</a></li>
<li><a href="#chunk-encoding">Chunk encoding
</a></li>
<li><a href="#settings-for-high-numbers-of-time-series">Settings for high numbers of time series
</a></li>
<li><a href="#persistence-urgency-and-%E2%80%9Crushed-mode%E2%80%9D">Persistence urgency and “rushed mode”
</a></li>
<li><a href="#settings-for-very-long-retention-time">Settings for very long retention time
</a></li>
<li><a href="#crash-recovery">Crash recovery
</a></li>
<li><a href="#data-corruption">Data corruption
</a></li>
<li><a href="#helpful-metrics">Helpful metrics
</a></li>
</ul></div>

<p>Prometheus has a sophisticated local storage subsystem. For indexes,
it uses <a href="https://github.com/google/leveldb">LevelDB</a>. For the bulk
sample data, it has its own custom storage layer, which organizes
sample data in chunks of constant size (1024 bytes payload). These
chunks are then stored on disk in one file per time series.</p>

<p>This sections deals with the various configuration settings and issues you
might run into. To dive deeper into the topic, check out the following talks:</p>

<ul>
<li>
<a href="https://www.youtube.com/watch?v=HbnGSNEjhUc">The Prometheus Time Series Database</a>.</li>
<li>
<a href="https://www.youtube.com/watch?v=hPC60ldCGm8">Configuring Prometheus for High Performance</a>.</li>
</ul>

<h2 id="memory-usage">Memory usage<a class="header-anchor" href="#memory-usage" name="memory-usage"></a>
</h2>

<p>Prometheus keeps all the currently used chunks in memory. In addition, it keeps
as many most recently used chunks in memory as possible. You have to tell
Prometheus how much memory it may use for this caching. The flag
<code>storage.local.target-heap-size</code> allows you to set the heap size (in bytes)
Prometheus aims not to exceed. Note that the amount of physical memory the
Prometheus server will use is the result of complex interactions of the Go
runtime and the operating system and very hard to predict precisely. As a rule
of thumb, you should have at least 50% headroom in physical memory over the
configured heap size. (Or, in other words, set <code>storage.local.target-heap-size</code>
to a value of two thirds of the physical memory limit Prometheus should not
exceed.)</p>

<p>The default value of <code>storage.local.target-heap-size</code> is 2GiB and thus tailored
to 3GiB of physical memory usage. If you have less physical memory available,
you have to lower the flag value. If you have more memory available, you should
raise the value accordingly. Otherwise, Prometheus will not make use of the
memory and thus will perform much worse than it could.</p>

<p>Because Prometheus uses most of its heap for long-lived allocations of memory
chunks, the
<a href="https://golang.org/pkg/runtime/debug/#SetGCPercent">garbage collection target percentage</a>
is set to 40 by default. You can still override this setting via the <code>GOGC</code>
environment variable as usual. If you need to conserve CPU capacity and can
accept running with fewer memory chunks, try higher values.</p>

<p>For high-performance set-ups, you might need to adjust more flags. Please read
through the sections below for details.</p>

<div class="admonition-wrapper note"><div class="admonition alert alert-info">Prior to v1.6, there was no flag <code>storage.local.target-heap-size</code>.
Instead, the number of chunks kept in memory had to be configured using the
flags <code>storage.local.memory-chunks</code> and <code>storage.local.max-chunks-to-persist</code>.
These flags still exist for compatibility reasons. However,
<code>storage.local.max-chunks-to-persist</code> has no effect anymore, and if
<code>storage.local.memory-chunks</code> is set to a non-zero value <em>x</em>, it is used to
override the value for <code>storage.local.target-heap-size</code> to 3072*<em>x</em>.</div></div>

<h2 id="disk-usage">Disk usage<a class="header-anchor" href="#disk-usage" name="disk-usage"></a>
</h2>

<p>Prometheus stores its on-disk time series data under the directory specified by
the flag <code>storage.local.path</code>. The default path is <code>./data</code> (relative to the
working directory), which is good to try something out quickly but most likely
not what you want for actual operations. The flag <code>storage.local.retention</code>
allows you to configure the retention time for samples. Adjust it to your needs
and your available disk space.</p>

<h2 id="chunk-encoding">Chunk encoding<a class="header-anchor" href="#chunk-encoding" name="chunk-encoding"></a>
</h2>

<p>Prometheus currently offers three different types of chunk encodings. The chunk
encoding for newly created chunks is determined by the
<code>-storage.local.chunk-encoding-version</code> flag. The valid values are 0, 1,
or 2.</p>

<p>Type 0 is the simple delta encoding implemented for Prometheus's first chunked
storage layer. Type 1 is the current default encoding, a double-delta encoding
with much better compression behavior than type 0. Both encodings feature a
fixed byte width per sample over the whole chunk, which allows fast random
access. While type 0 is the fastest encoding, the difference in encoding cost
compared to encoding 1 is tiny. Due to the better compression behavior of type
1, there is really no reason to select type 0 except compatibility with very
old Prometheus versions.</p>

<p>Type 2 is a variable bit-width encoding, i.e. each sample in the chunk can use
a different number of bits. Timestamps are double-delta encoded, too, but with
a slightly different algorithm. A number of different encoding schemes are
available for sample values. The choice is made per chunk based on the nature
of the sample values (constant, integer, regularly increasing, random…). Major
parts of the type 2 encoding are inspired by a paper published by Facebook
engineers:
<a href="http://www.vldb.org/pvldb/vol8/p1816-teller.pdf"><em>Gorilla: A Fast, Scalable, In-Memory Time Series Database</em></a>.</p>

<p>With type 2, access within a chunk has to happen sequentially, and the encoding
and decoding cost is a bit higher. Overall, type 2 will cause more CPU usage
and increased query latency compared to type 1 but offers a much improved
compression ratio. The exact numbers depend heavily on the data set and the
kind of queries. Below are results from a typical production server with a
fairly expensive set of recording rules.</p>

<table class=" table table-bordered">
<thead>
<tr>
<th style="text-align: center">Chunk type</th>
<th style="text-align: center">bytes per sample</th>
<th style="text-align: center">cores</th>
<th style="text-align: center">rule evaluation duration</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: center">3.3</td>
<td style="text-align: center">1.6</td>
<td style="text-align: center">2.9s</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: center">1.3</td>
<td style="text-align: center">2.4</td>
<td style="text-align: center">4.9s</td>
</tr>
</tbody>
</table>

<p>You can change the chunk encoding each time you start the server, so
experimenting with your own use case is encouraged. Take into account, however,
that only newly created chunks will use the newly selected chunk encoding, so
it will take a while until you see the effects.</p>

<p>For more details about the trade-off between the chunk encodings, see
<a href="/blog/2016/05/08/when-to-use-varbit-chunks/">this blog post</a>.</p>

<h2 id="settings-for-high-numbers-of-time-series">Settings for high numbers of time series<a class="header-anchor" href="#settings-for-high-numbers-of-time-series" name="settings-for-high-numbers-of-time-series"></a>
</h2>

<p>Prometheus can handle millions of time series. However, with the above
mentioned default setting for <code>storage.local.target-heap-size</code>, you will be
limited to about 200,000 time series simultaneously present in memory. For more
series, you need more memory, and you need to configure Prometheus to make use
of it as described above.</p>

<p>Each of the aforementioned chunks contains samples of a single time series. A
time series is thus represented as a series of chunks, which ultimately end up
in a time series file (one file per time series) on disk.</p>

<p>A series that has recently received new samples will have an open incomplete
<em>head chunk</em>. Once that chunk is completely filled, or the series hasn't
received samples in a while, the head chunk is closed and becomes a chunk
waiting to be appended to its corresponding series file, i.e. it is <em>waiting
for persistence</em>. After the chunk has been persisted to disk, it becomes
<em>evictable</em>, provided it is not currently used by a query. Prometheus will
evict evictable chunks from memory to satisfy the configured target heap
size. A series with an open head chunk is called an <em>active series</em>. This is
different from a <em>memory series</em>, which also includes series without an open
head chunk but still other chunks in memory (whether waiting for persistence,
used in a query, or evictable). A series without any chunks in memory may be
<em>archived</em>, upon which it ceases to have any mandatory memory footprint.</p>

<p>The amount of chunks Prometheus can keep in memory depends on the flag value
for <code>storage.local.target-heap-size</code> and on the amount of memory used by
everything else. If there are not enough chunks evictable to satisfy the target
heap size, Prometheus will throttle ingestion of more samples (by skipping
scrapes and rule evaluations) until the heap has shrunk enough. <em>Throttled
ingestion is really bad for various reasons. You really do not want to be in
that situation.</em></p>

<p>Open head chunks, chunks still waiting for persistence, and chunks being used
in a query are not evictable. Thus, the reasons for the inability to evict
enough chunks include the following:</p>

<ol>
<li>Queries that use too many chunks.</li>
<li>Chunks are piling up waiting for persistence because the storage layer
cannot keep up writing chunks.</li>
<li>There are too many active time series, which results in too many open head
chunks.</li>
</ol>

<p>Currently, Prometheus has no defence against case (1). Abusive queries will
essentially OOM the server.</p>

<p>To defend against case (2), there is a concept of persistence urgency explained
in the next section.</p>

<p>Case (3) depends on the targets you monitor. To mitigate an unplanned explosion
of the number of series, you can limit the number of samples per individual
scrape (see <code>sample_limit</code> in the
<a href="/docs/operating/configuration/#scrape_config">scrape config</a>).
If the number of active time series exceeds the number of memory chunks the
Prometheus server can afford, the server will quickly throttle ingestion as
described above. The only way out of this is to give Prometheus more RAM or
reduce the number of time series to ingest.</p>

<p>In fact, you want many more memory chunks than you have series in
memory. Prometheus tries to batch up disk writes as much as possible as it
helps for both HDD (write as much as possible after each seek) and SSD (tiny
writes create write amplification, which limits the effective throughput and
burns much more quickly through the lifetime of the device). The more
Prometheus can batch up writes, the more efficient is the process of persisting
chunks to disk. which helps case (2).</p>

<p>In conclusion, to keep the Prometheus server healthy, make sure it has plenty
of headroom of memory chunks available for the number of memory series. A
factor of three is a good starting point. Refer to the
<a href="#helpful-metrics">section about helpful metrics</a> to find out what to look
for. A very broad rule of thumb for an upper limit of memory series is the
total available physical memory divided by 10,000, e.g. About 6M memory series
on a 64GiB server.</p>

<p>If you combine a high number of time series with very fast and/or large
scrapes, the number of pre-allocated mutexes for series locking might not be
sufficient. If you see scrape hiccups while Prometheus is writing a checkpoint
or processing expensive queries, try increasing the value of the
<code>storage.local.num-fingerprint-mutexes</code> flag. Sometimes tens of thousands or
even more are required.</p>

<p>PromQL queries that involve a high number of time series will make heavy use of
the LevelDB-backed indexes. If you need to run queries of that kind, tweaking
the index cache sizes might be required. The following flags are relevant:</p>

<ul>
<li>
<code>-storage.local.index-cache-size.label-name-to-label-values</code>: For regular
expression matching.</li>
<li>
<code>-storage.local.index-cache-size.label-pair-to-fingerprints</code>: Increase the
size if a large number of time series share the same label pair or name.</li>
<li>
<code>-storage.local.index-cache-size.fingerprint-to-metric</code> and
<code>-storage.local.index-cache-size.fingerprint-to-timerange</code>: Increase the size
if you have a large number of archived time series, i.e. series that have not
received samples in a while but are still not old enough to be purged
completely.</li>
</ul>

<p>You have to experiment with the flag values to find out what helps. If a query
touches 100,000+ time series, hundreds of MiB might be reasonable. If you have
plenty of memory available, using more of it for LevelDB cannot harm. More
memory for LevelDB will effectively reduce the number of memory chunks
Prometheus can afford.</p>

<h2 id="persistence-urgency-and-“rushed-mode”">Persistence urgency and “rushed mode”<a class="header-anchor" href="#persistence-urgency-and-rushed-mode" name="persistence-urgency-and-rushed-mode"></a>
</h2>

<p>Naively, Prometheus would all the time try to persist completed chunk to disk
as soon as possible. Such a strategy would lead to many tiny write operations,
using up most of the I/O bandwidth and keeping the server quite busy. Spinning
disks will appear to be very slow because of the many slow seeks required, and
SSDs will suffer from write amplification. Prometheus tries instead to batch up
write operations as much as possible, which works better if it is allowed to
use more memory.</p>

<p>Prometheus will also sync series files after each write (with
<code>storage.local.series-sync-strategy=adaptive</code>, which is the default) and use
the disk bandwidth for more frequent checkpoints (based on the count of “dirty
series”, see <a href="#crash-recovery">below</a>), both attempting to minimize data loss
in case of a crash.</p>

<p>But what to do if the number of chunks waiting for persistence grows too much?
Prometheus calculates a score for urgency to persist chunks. The score is
between 0 and 1, where 1 corresponds to the highest urgency. Depending on the
score, Prometheus will write to disk more frequently. Should the score ever
pass the threshold of 0.8, Prometheus enters “rushed mode” (which you can see
in the logs). In rushed mode, the following strategies are applied to speed up
persisting chunks:</p>

<ul>
<li>Series files are not synced after write operations anymore (making better use
of the OS's page cache at the price of an increased risk of losing data in
case of a server crash – this behavior can be overridden with the flag
<code>storage.local.series-sync-strategy</code>).</li>
<li>Checkpoints are only created as often as configured via the
<code>storage.local.checkpoint-interval</code> flag (freeing more disk bandwidth for
persisting chunks at the price of more data loss in case of a crash and an
increased time to run the subsequent crash recovery).</li>
<li>Write operations to persist chunks are not throttled anymore and performed as
fast as possible.</li>
</ul>

<p>Prometheus leaves rushed mode once the score has dropped below 0.7.</p>

<p>Throttling of ingestion happens if the urgency score reaches 1. Thus, the
rushed mode is not <em>per se</em> something to be avoided. It is, on the contrary, a
measure the Prometheus server takes to avoid the really bad situation of
throttled ingestion. Occasionally entering rushed mode is OK, if it helps and
ultimately leads to leaving rushed mode again. <em>If rushed mode is entered but
the urgency score still goes up, the server has a real problem.</em></p>

<h2 id="settings-for-very-long-retention-time">Settings for very long retention time<a class="header-anchor" href="#settings-for-very-long-retention-time" name="settings-for-very-long-retention-time"></a>
</h2>

<p>If you have set a very long retention time via the <code>storage.local.retention</code>
flag (more than a month), you might want to increase the flag value
<code>storage.local.series-file-shrink-ratio</code>.</p>

<p>Whenever Prometheus needs to cut off some chunks from the beginning of a series
file, it will simply rewrite the whole file. (Some file systems support “head
truncation”, which Prometheus currently does not use for several reasons.) To
not rewrite a very large series file to get rid of very few chunks, the rewrite
only happens if at least 10% of the chunks in the series file are removed. This
value can be changed via the mentioned <code>storage.local.series-file-shrink-ratio</code>
flag. If you have a lot of disk space but want to minimize rewrites (at the
cost of wasted disk space), increase the flag value to higher values, e.g. 0.3
for 30% of required chunk removal.</p>

<h2 id="crash-recovery">Crash recovery<a class="header-anchor" href="#crash-recovery" name="crash-recovery"></a>
</h2>

<p>Prometheus saves chunks to disk as soon as possible after they are
complete. Incomplete chunks are saved to disk during regular
checkpoints. You can configure the checkpoint interval with the flag
<code>storage.local.checkpoint-interval</code>. Prometheus creates checkpoints
more frequently than that if too many time series are in a “dirty”
state, i.e. their current incomplete head chunk is not the one that is
contained in the most recent checkpoint. This limit is configurable
via the <code>storage.local.checkpoint-dirty-series-limit</code> flag.</p>

<p>More active time series to cycle through lead in general to more chunks waiting
for persistence, which in turns leads to larger checkpoints and ultimately more
time needed for checkpointing. There is a clear trade-off between limiting the
loss of data in case of a crash and the ability to scale to high number of
active time series. To not spend the majority of the disk throughput for
checkpointing, you have to increase the checkpoint interval. Prometheus itself
limits the time spent in checkpointing to 50% by waiting after each
checkpoint's completion for at least as long as the previous checkpoint took.</p>

<p>Nevertheless, should your server crash, you might still lose data, and
your storage might be left in an inconsistent state. Therefore,
Prometheus performs a crash recovery after an unclean shutdown,
similar to an <code>fsck</code> run for a file system. Details about the crash
recovery are logged, so you can use it for forensics if required. Data
that cannot be recovered is moved to a directory called <code>orphaned</code>
(located under <code>storage.local.path</code>). Remember to delete that data if
you do not need it anymore.</p>

<p>The crash recovery usually takes less than a minute. Should it take much
longer, consult the log to find out what is going on. With increasing number of
time series in the storage (archived or not), the re-indexing tends to dominate
the recovery time and can take tens of minutes in extreme cases.</p>

<h2 id="data-corruption">Data corruption<a class="header-anchor" href="#data-corruption" name="data-corruption"></a>
</h2>

<p>If you suspect problems caused by corruption in the database, you can
enforce a crash recovery by starting the server with the flag
<code>storage.local.dirty</code>.</p>

<p>If that does not help, or if you simply want to erase the existing
database, you can easily start fresh by deleting the contents of the
storage directory:</p>

<ol>
<li>Stop Prometheus.</li>
<li><code>rm -r &lt;storage path&gt;/*</code></li>
<li>Start Prometheus.</li>
</ol>

<h2 id="helpful-metrics">Helpful metrics<a class="header-anchor" href="#helpful-metrics" name="helpful-metrics"></a>
</h2>

<p>Out of the metrics that Prometheus exposes about itself, the following are
particularly useful to tweak flags and find out about the required
resources. They also help to create alerts to find out in time if a Prometheus
server has problems or is out of capacity.</p>

<ul>
<li>
<code>prometheus_local_storage_memory_series</code>: The current number of series held
in memory.</li>
<li>
<code>prometheus_local_storage_open_head_chunks</code>: The number of open head chunks.</li>
<li>
<code>prometheus_local_storage_chunks_to_persist</code>: The number of memory chunks
that still need to be persisted to disk.</li>
<li>
<code>prometheus_local_storage_memory_chunks</code>: The current number of chunks held
in memory. If you substract the previous two, you get the number of persisted
chunks (which are evictable if not currently in use by a query).</li>
<li>
<code>prometheus_local_storage_series_chunks_persisted</code>: A histogram of the number
of chunks persisted per batch.</li>
<li>
<code>prometheus_local_storage_persistence_urgency_score</code>: The urgency score as
discussed <a href="#persistence-urgency-and-rushed-mode">above</a>.</li>
<li>
<code>prometheus_local_storage_rushed_mode</code> is 1 if Prometheus is in “rushed
mode”, 0 otherwise. Can be used to calculate the percentage of time
Prometheus is in rushed mode.</li>
<li>
<code>prometheus_local_storage_checkpoint_last_duration_seconds</code>: How long the
last checkpoint took.</li>
<li>
<code>prometheus_local_storage_checkpoint_last_size_bytes</code>: Size of the last
checkpoint in bytes.</li>
<li>
<code>prometheus_local_storage_checkpointing</code> is 1 while Prometheus is
checkpointing, 0 otherwise. Can be used to calculate the percentage of time
Prometheus is checkpointing.</li>
<li>
<code>prometheus_local_storage_inconsistencies_total</code>: Counter for storage
inconsistencies found. If this is greater than 0, restart the server for
recovery.</li>
<li>
<code>prometheus_local_storage_persist_errors_total</code>: Counter for persist errors.</li>
<li>
<code>prometheus_local_storage_memory_dirty_series</code>: Current number of dirty series.</li>
<li>
<code>process_resident_memory_bytes</code>: Broadly speaking the physical memory
occupied by the Prometheus process.</li>
<li>
<code>go_memstats_alloc_bytes</code>: Go heap size (allocated objects in use plus allocated
objects not in use anymore but not yet garbage-collected).</li>
</ul>
</body></html>

    </div>

  </div>
  <hr>

<footer>
  <p class="pull-left">
    &copy; Prometheus Authors 2017
  </p>
</footer>

</div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-2.2.2.min.js" integrity="sha256-36cp2Co+/62rEAAYHLmRCPIych47CvdM+uTBJwSzWjI=" crossorigin="anonymous"></script>
    <script src="/assets/bootstrap-3.3.1/js/bootstrap.min-cb2616d3564.js"></script>
    <script src="/assets/docs-cb53fb1bfd3.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="/assets/ie10-viewport-bug-workaround-cbb5a0dd7ce.js"></script>
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-58468480-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>

