<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Prometheus monitoring system and time series database">
    <meta name="keywords" content="prometheus, monitoring, monitoring system, time series, time series database, alerting, metrics, telemetry">
    <meta name="author" content="Prometheus">

    <link rel="alternate" type="application/atom+xml" title="Prometheus Blog » Feed" href="/blog/feed.xml">

    <link rel="shortcut icon" href="/assets/favicons/favicon.ico">
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/favicons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/favicons/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/favicons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/favicons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/favicons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/favicons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/favicons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/favicons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/assets/favicons/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/assets/favicons/android-chrome-manifest.json">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/assets/favicons/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">

    
    <title>Blog | Prometheus</title>
    

    <!-- Bootstrap core CSS -->
    <link href="/assets/bootstrap-3.3.1/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="/assets/docs.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="/assets/font-awesome-4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-static-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"><img src="/assets/prometheus_logo_grey.svg" alt="Prometheus logo"> Prometheus</a>
        </div>
        <div class="collapse navbar-collapse" id="navbar">
          <ul class="nav navbar-nav navbar-right main-nav">
            <li><a href="/">Overview</a></li>
            <li><a href="/docs/introduction/overview/">Documentation</a></li>
            <li><a href="/community/">Community</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="https://github.com/prometheus"><i class="fa fa-github"></i> Github</a></li>
          </ul>
        </div>
      </div>
    </nav>


<div class="container">
  <div class="col-md-9">
  
    <div class="blog doc-content">
      <h1><a href="/blog/2015/08/17/service-discovery-with-etcd/">Custom service discovery with etcd</a></h1>
      <aside>Posted at: August 17, 2015 by Fabian Reinartz</aside>
      <article class="doc-content">
        <p>In a <a href="/blog/2015/06/01/advanced-service-discovery/">previous post</a> we
introduced numerous new ways of doing service discovery in Prometheus.
Since then a lot has happened. We improved the internal implementation and
received fantastic contributions from our community, adding support for
service discovery with Kubernetes and Marathon. They will become available
with the release of version 0.16.</p>

<p>We also touched on the topic of <a href="/blog/2015/06/01/advanced-service-discovery/#custom-service-discovery">custom service discovery</a>.</p>

<p>Not every type of service discovery is generic enough to be directly included
in Prometheus. Chances are your organisation has a proprietary
system in place and you just have to make it work with Prometheus.
This does not mean that you cannot enjoy the benefits of automatically
discovering new monitoring targets.</p>

<p>In this post we will implement a small utility program that connects a custom
service discovery approach based on <a href="https://coreos.com/etcd/">etcd</a>, the
highly consistent distributed key-value store, to Prometheus.</p>

<h2 id="targets-in-etcd-and-prometheus">Targets in etcd and Prometheus<a class="header-anchor" href="#targets-in-etcd-and-prometheus" name="targets-in-etcd-and-prometheus"></a>
</h2>

<p>Our fictional service discovery system stores services and their
instances under a well-defined key schema:</p>

<pre><code>/services/&lt;service_name&gt;/&lt;instance_id&gt; = &lt;instance_address&gt;
</code></pre>

<p>Prometheus should now automatically add and remove targets for all existing
services as they come and go.
We can integrate with Prometheus's file-based service discovery, which
monitors a set of files that describe targets as lists of target groups in
JSON format.</p>

<p>A single target group consists of a list of addresses associated with a set of
labels. Those labels are attached to all time series retrieved from those
targets.
One example target group extracted from our service discovery in etcd could
look like this:</p>

<pre><code>{
  "targets": ["10.0.33.1:54423", "10.0.34.12:32535"],
  "labels": {
    "job": "node_exporter"
  }
}
</code></pre>

<h2 id="the-program">The program<a class="header-anchor" href="#the-program" name="the-program"></a>
</h2>

<p>What we need is a small program that connects to the etcd cluster and performs
a lookup of all services found in the <code>/services</code> path and writes them out into
a file of target groups.</p>

<p>Let's get started with some plumbing. Our tool has two flags: the etcd server
to connect to and the file to which the target groups are written. Internally,
the services are represented as a map from service names to instances.
Instances are a map from the instance identifier in the etcd path to its
address.</p>

<pre><code>const servicesPrefix = "/services"

type (
  instances map[string]string
  services  map[string]instances
)

var (
  etcdServer = flag.String("server", "http://127.0.0.1:4001", "etcd server to connect to")
  targetFile = flag.String("target-file", "tgroups.json", "the file that contains the target groups")
)
</code></pre>

<p>Our <code>main</code> function parses the flags and initializes our object holding the
current services. We then connect to the etcd server and do a recursive read
of the <code>/services</code> path.
We receive the subtree for the given path as a result and call <code>srvs.handle</code>,
which recursively performs the <code>srvs.update</code> method for each node in the
subtree. The <code>update</code> method modifies the state of our <code>srvs</code> object to be
aligned with the state of our subtree in etcd.
Finally, we call <code>srvs.persist</code> which transforms the <code>srvs</code> object into a list
of target groups and writes them out to the file specified by the
<code>-target-file</code> flag.</p>

<pre><code>func main() {
  flag.Parse()

  var (
    client  = etcd.NewClient([]string{*etcdServer})
    srvs    = services{}
  )

  // Retrieve the subtree of the /services path.
  res, err := client.Get(servicesPrefix, false, true)
  if err != nil {
    log.Fatalf("Error on initial retrieval: %s", err)
  }
  srvs.handle(res.Node, srvs.update)
  srvs.persist()
}
</code></pre>

<p>Let's assume we have this as a working implementation. We could now run this
tool every 30 seconds to have a mostly accurate view of the current targets in
our service discovery.</p>

<p>But can we do better?</p>

<p>The answer is <em>yes</em>. etcd provides watches, which let us listen for updates on
any path and its sub-paths. With that, we are informed about changes
immediately and can apply them immediately. We also don't have to work through
the whole <code>/services</code> subtree again and again, which can become important for
a large number of services and instances.</p>

<p>We extend our <code>main</code> function as follows:</p>

<pre><code>func main() {
  // ...

  updates := make(chan *etcd.Response)

  // Start recursively watching for updates.
  go func() {
    _, err := client.Watch(servicesPrefix, 0, true, updates, nil)
    if err != nil {
      log.Errorln(err)
    }
  }()

  // Apply updates sent on the channel.
  for res := range updates {
    log.Infoln(res.Action, res.Node.Key, res.Node.Value)

    handler := srvs.update
    if res.Action == "delete" {
      handler = srvs.delete
    }
    srvs.handle(res.Node, handler)
    srvs.persist()
  }
}
</code></pre>

<p>We start a goroutine that recursively watches for changes to entries in
<code>/services</code>. It blocks forever and sends all changes to the <code>updates</code> channel.
We then read the updates from the channel and apply it as before. In case an
instance or entire service disappears however, we call <code>srvs.handle</code> using the
<code>srvs.delete</code> method instead.</p>

<p>We finish each update by another call to <code>srvs.persist</code> to write out the
changes to the file Promtheus is watching.</p>

<h3 id="modification-methods">Modification methods<a class="header-anchor" href="#modification-methods" name="modification-methods"></a>
</h3>

<p>So far so good – conceptually this works. What remains are the <code>update</code> and
<code>delete</code> handler methods as well as the <code>persist</code> method.</p>

<p><code>update</code> and <code>delete</code> are invoked by the <code>handle</code> method which simply calls
them for each node in a subtree, given that the path is valid:</p>

<pre><code>var pathPat = regexp.MustCompile(`/services/([^/]+)(?:/(\d+))?`)

func (srvs services) handle(node *etcd.Node, handler func(*etcd.Node)) {
  if pathPat.MatchString(node.Key) {
    handler(node)
  } else {
    log.Warnf("unhandled key %q", node.Key)
  }

  if node.Dir {
    for _, n := range node.Nodes {
      srvs.handle(n, handler)
    }
  }
}
</code></pre>

<h4 id="update">
<code>update</code><a class="header-anchor" href="#update" name="update"></a>
</h4>

<p>The update methods alters the state of our <code>services</code> object
based on the node which was updated in etcd.</p>

<pre><code>func (srvs services) update(node *etcd.Node) {
  match := pathPat.FindStringSubmatch(node.Key)
  // Creating a new job directory does not require any action.
  if match[2] == "" {
    return
  }
  srv := match[1]
  instanceID := match[2]

  // We received an update for an instance.
  insts, ok := srvs[srv]
  if !ok {
    insts = instances{}
    srvs[srv] = insts
  }
  insts[instanceID] = node.Value
}
</code></pre>

<h4 id="delete">
<code>delete</code><a class="header-anchor" href="#delete" name="delete"></a>
</h4>

<p>The delete methods removes instances or entire jobs from our <code>services</code>
object depending on which node was deleted from etcd.</p>

<pre><code>func (srvs services) delete(node *etcd.Node) {
  match := pathPat.FindStringSubmatch(node.Key)
  srv := match[1]
  instanceID := match[2]

  // Deletion of an entire service.
  if instanceID == "" {
    delete(srvs, srv)
    return
  }

  // Delete a single instance from the service.
  delete(srvs[srv], instanceID)
}
</code></pre>

<h4 id="persist">
<code>persist</code><a class="header-anchor" href="#persist" name="persist"></a>
</h4>

<p>The persist method transforms the state of our <code>services</code> object into a list of <code>TargetGroup</code>s. It then writes this list into the <code>-target-file</code> in JSON
format.</p>

<pre><code>type TargetGroup struct {
  Targets []string          `json:"targets,omitempty"`
  Labels  map[string]string `json:"labels,omitempty"`
}

func (srvs services) persist() {
  var tgroups []*TargetGroup
  // Write files for current services.
  for job, instances := range srvs {
    var targets []string
    for _, addr := range instances {
      targets = append(targets, addr)
    }

    tgroups = append(tgroups, &amp;TargetGroup{
      Targets: targets,
      Labels:  map[string]string{"job": job},
    })
  }

  content, err := json.Marshal(tgroups)
  if err != nil {
    log.Errorln(err)
    return
  }

  f, err := create(*targetFile)
  if err != nil {
    log.Errorln(err)
    return
  }
  defer f.Close()

  if _, err := f.Write(content); err != nil {
    log.Errorln(err)
  }
}
</code></pre>

<h2 id="taking-it-live">Taking it live<a class="header-anchor" href="#taking-it-live" name="taking-it-live"></a>
</h2>

<p>All done, so how do we run this?</p>

<p>We simply start our tool with a configured output file:</p>

<pre><code>./etcd_sd -target-file /etc/prometheus/tgroups.json
</code></pre>

<p>Then we configure Prometheus with file based service discovery
using the same file. The simplest possible configuration looks like this:</p>

<pre><code>scrape_configs:
- job_name: 'default' # Will be overwritten by job label of target groups.
  file_sd_configs:
  - names: ['/etc/prometheus/tgroups.json']
</code></pre>

<p>And that's it. Now our Prometheus stays in sync with services and their
instances entering and leaving our service discovery with etcd.</p>

<h2 id="conclusion">Conclusion<a class="header-anchor" href="#conclusion" name="conclusion"></a>
</h2>

<p>If Prometheus does not ship with native support for the service discovery of
your organisation, don't despair. Using a small utility program you can easily
bridge the gap and profit from seamless updates to the monitored targets.
Thus, you can remove changes to the monitoring configuration from your
deployment equation.</p>

<p>A big thanks to our contributors <a href="https://twitter.com/jimmidyson">Jimmy Dyson</a>
and <a href="https://twitter.com/xperimental">Robert Jacob</a> for adding native support
for <a href="http://kubernetes.io/">Kubernetes</a> and <a href="https://mesosphere.github.io/marathon/">Marathon</a>.
Also check out <a href="https://twitter.com/keegan_csmith">Keegan C Smith's</a> take on <a href="https://github.com/keegancsmith/prometheus-ec2-discovery">EC2 service discovery</a> based on files.</p>

<p>You can find the <a href="https://github.com/fabxc/prom_sd_example/tree/master/etcd_simple">full source of this blog post on GitHub</a>.</p>

      </article>
    </div>
  
    <div class="blog doc-content">
      <h1><a href="/blog/2015/06/24/monitoring-dreamhack/">Monitoring DreamHack - the World's Largest Digital Festival</a></h1>
      <aside>Posted at: June 24, 2015 by Christian Svensson (DreamHack Network Team)</aside>
      <article class="doc-content">
        <p><em>Editor's note: This article is a guest post written by a Prometheus user.</em></p>

<p><strong>If you are operating the network for 10,000's of demanding gamers, you need to
really know what is going on inside your network. Oh, and everything needs to be
built from scratch in just five days.</strong></p>

<p>If you have never heard about <a href="http://www.dreamhack.se/">DreamHack</a> before, here
is the pitch: Bring 20,000 people together and have the majority of them bring
their own computer.  Mix in professional gaming (eSports), programming contests,
and live music concerts. The result is the world's largest festival dedicated
solely to everything digital.</p>

<p>To make such an event possible, there needs to be a lot of infrastructure in
place. Ordinary infrastructures of this size take months to build, but the crew
at DreamHack builds everything from scratch in just five days. This of course
includes stuff like configuring network switches, but also building the
electricity distribution, setting up stores for food and drinks, and even
building the actual tables.</p>

<p>The team that builds and operates everything related to the network is
officially called the Network team, but we usually refer to ourselves as <em>tech</em>
or <em>dhtech</em>. This post is going to focus on the work of dhtech and how we used
Prometheus during DreamHack Summer 2015 to try to kick our monitoring up another
notch.</p>

<h2 id="the-equipment">The equipment<a class="header-anchor" href="#the-equipment" name="the-equipment"></a>
</h2>

<p>Turns out that to build a highly performant network for 10,000+
computers, you need at least the same number of network ports. In our case these
come in the form of ~400 Cisco 2950 switches. We call these the access switches.
These are everywhere in the venue where participants will be seated with their
computers.</p>

<p><a href="https://www.flickr.com/photos/dreamhack/8206439882"><img src="https://c1.staticflickr.com/9/8487/8206439882_4739d39a9c_c.jpg" alt="Access switches"></a>
</p><center><em>Dutifully standing in line, the access switches are ready to greet the
DreamHackers with high-speed connectivity.</em></center>

<p>Obviously just connecting all these computers to a switch is not enough. That
switch needs to be connected to the other switches as well. This is where the
distribution switches (or dist switches) come into play. These are switches that
take the hundreds of links from all access switches and aggregate them into
more manageable 10-Gbit/s high-capacity fibre. The dist switches are then
further aggregated into our core, where the traffic is routed to its
destination.</p>

<p>On top of all of this, we operate our own WiFi networks, DNS/DHCP servers, and
other infrastructure. When completed, our core looks something like the image
below.</p>

<p><a href="https://www.flickr.com/photos/dreamhack/18679671439"><img src="https://c2.staticflickr.com/4/3951/18679671439_10ce7a8eb4_c.jpg" alt="The DreamHack network core"></a>
</p><center><em>The DreamHack network core</em></center>

<p><a href="http://i.imgur.com/ZCQa2Ab.png"><img src="http://i.imgur.com/ZCQa2Abl.png" alt="Network planning map"></a>
</p><center><em>The planning map for the distribution and core layers. The core is
clearly visible in "Hall D"</em></center>

<p>All in all this is becoming a lengthy list of stuff to monitor, so let's get to
the reason you're here: How do we make sure we know what's going on?</p>

<h2 id="introducing:-dhmon">Introducing: dhmon<a class="header-anchor" href="#introducing-dhmon" name="introducing-dhmon"></a>
</h2>

<p>dhmon is the collective name of the systems that not only
monitor the network, but also allow other teams to collect metrics on whatever
they want.</p>

<p>Since the network needs to be built in five days, it's essential that the
monitoring systems are easy to set up and keep in sync if we need to do last
minute infrastructural changes (like adding or removing devices). When we start
to build the network, we need monitoring as soon as possible to be able to
discover any problems with the equipment or other issues we hadn't foreseen.</p>

<p>In the past we have tried to use a mix of commonly available software such as
Cacti, SNMPc, and Opsview among others. While these have worked they have focused on
being closed systems and only provided the bare minimum. A few years back a few
people from the team said "Enough, we can do better ourselves!" and started
writing a custom monitoring solution.</p>

<p>At the time the options were limited. Over the years the system went from using
Graphite (scalability issues), a custom Cassandra store (high complexity), and
InfluxDB (immature software) to finally land on using Prometheus. I first
learned about Prometheus back in 2014 when I met Julius Volz and I had been
eager to try it ever since. This summer we finally replaced the custom
InfluxDB-based metrics store that we had written with Prometheus. Spoiler: We're
not going back.</p>

<h2 id="the-architecture">The architecture<a class="header-anchor" href="#the-architecture" name="the-architecture"></a>
</h2>

<p>The monitoring solution consists of three layers:
collection, storage, presentation. Our most critical collectors are
snmpcollector (SNMP) and ipplan-pinger (ICMP), closely followed by dhcpinfo
(DHCP lease stats). We also have some scripts that dump stats about other
systems into <a href="https://github.com/prometheus/node_exporter">node_exporter</a>'s
textfile collector.</p>

<p><a href="http://i.imgur.com/6gN3MRp.png"><img src="http://i.imgur.com/6gN3MRp.png" alt="dhmon Architecture"></a>
</p><center><em>The current architecture plan of dhmon as of Summer 2015</em></center>

<p>We use Prometheus as a central timeseries storage and querying engine, but we
also use Redis and memcached to export snapshot views of binary information that
we collect but cannot store in Prometheus in any sensible way, or when we need
to access very fresh data.</p>

<p>One such case is in our presentation layer. We use our dhmap web application to
get an overview of the overall health of the access switches. In order to be
effective at resolving errors, we need a latency of ~10 seconds from data
collection to presentation. Our goal is to have fixed the problem before the
customer notices, or at least before they have walked over to the support people
to report an issue. For this reason, we have been using memcached since the
beginning to access the latest snapshot of the network.</p>

<p>We continued to use memcached this year for our low-latency data, while using
Prometheus for everything that's historical or not as latency-sensitive. This
decision was made simply because we were unsure how Prometheus would perform at
very short sampling intervals. In the end, we found no reason for why we can't
use Prometheus for this data as well - we will definitely try to replace our
memcached with Prometheus at the next DreamHack.</p>

<p><a href="http://i.imgur.com/D5I0Ztb.png"><img src="http://i.imgur.com/D5I0Ztbl.png" alt="dhmon Visualization"></a>
</p><center><em>The overview of our access layer visualized by dhmon</em></center>

<h2 id="prometheus-setup">Prometheus setup<a class="header-anchor" href="#prometheus-setup" name="prometheus-setup"></a>
</h2>

<p>The block that so far has been referred to as <em>Prometheus</em>
really consists of three products:
<a href="https://github.com/prometheus/prometheus">Prometheus</a>,
<a href="https://github.com/prometheus/promdash">PromDash</a>, and
<a href="https://github.com/prometheus/alertmanager">Alertmanager</a>. The setup is fairly
basic and all three components are running on the same host. Everything is
served by an Apache web server that just acts as a reverse proxy.</p>

<pre><code>ProxyPass /prometheus http://localhost:9090/prometheus
ProxyPass /alertmanager http://localhost:9093/alertmanager
ProxyPass /dash http://localhost:3000/dash
</code></pre>

<h2 id="exploring-the-network">Exploring the network<a class="header-anchor" href="#exploring-the-network" name="exploring-the-network"></a>
</h2>

<p>Prometheus has a powerful querying engine that allows
you to do pretty cool things with the streaming information collected from all
over your network. However, sometimes the queries need to process too much data
to finish within a reasonable amount of time. This happened to us when we wanted
to graph the top 5 utilized links out of ~18,000 in total. While the query
worked, it would take roughly the amount of time we set our timeout limit to,
meaning it was both slow and flaky. We decided to use Prometheus' <a href="/docs/querying/rules/">recording
rules</a> for precomputing heavy queries.</p>

<pre><code>precomputed_link_utilization_percent = rate(ifHCOutOctets{layer!='access'}[10m])*8/1000/1000
                                         / on (device,interface,alias)
                                       ifHighSpeed{layer!='access'}
</code></pre>

<p>After this, running <code>topk(5, precomputed_link_utilization_percent)</code> was
blazingly fast.</p>

<h2 id="being-reactive:-alerting">Being reactive: alerting<a class="header-anchor" href="#being-reactive-alerting" name="being-reactive-alerting"></a>
</h2>

<p>So at this stage we had something we could query for
the state of the network. Since we are humans, we don't want to spend our time
running queries all the time to see if things are still running as they should,
so obviously we need alerting.</p>

<p>For example: we know that all our access switches use GigabitEthernet0/2 as an
uplink. Sometimes when the network cables have been in storage for too long they
oxidize and are not able to negotiate the full 1000 Mbps that we want.</p>

<p>The negotiated speed of a network port can be found in the SNMP OID
<code>IF-MIB::ifHighSpeed</code>. People familiar with SNMP will however recognize that
this OID is indexed by an arbitrary interface index. To make any sense of this
index, we need to cross-reference it with data from SNMP OID <code>IF-MIB::ifDescr</code>
to retrieve the actual interface name.</p>

<p>Fortunately, our snmpcollector supports this kind of cross-referencing while
generating Prometheus metrics. This allows us in a simple way to not only query
data, but also define useful alerts. In our setup we configured the SNMP
collection to annotate any metric under the <code>IF-MIB::ifTable</code> and
<code>IF-MIB::ifXTable</code> OIDs with <code>ifDescr</code>. This will come in handy now when we need
to specify that we are only interested in the <code>GigabitEthernet0/2</code> port and no
other interface.</p>

<p>Let's have a look at what such an alert definition looks like.</p>

<pre><code>ALERT BadUplinkOnAccessSwitch
  IF ifHighSpeed{layer='access', interface='GigabitEthernet0/2'} &lt; 1000 FOR 2m
  SUMMARY "Interface linking at {{$value}} Mbps"
  DESCRIPTION "Interface {{$labels.interface}} on {{$labels.device}} linking at {{$value}} Mbps"
</code></pre>

<p>Done! Now we will get an alert if a switch's uplink suddenly links at a
non-optimal speed.</p>

<p>Let's also look at how an alert for an almost full DHCP scope looks like:</p>

<pre><code>ALERT DhcpScopeAlmostFull
  IF ceil((dhcp_leases_current_count / dhcp_leases_max_count)*100) &gt; 90 FOR 2m
  SUMMARY "DHCP scope {{$labels.network}} is almost full"
  DESCRIPTION "DHCP scope {{$labels.network}} is {{$value}}% full"
</code></pre>

<p>We found the syntax to define alerts easy to read and understand even if you had
no previous experience with Prometheus or time series databases.</p>

<p><a href="http://i.imgur.com/RV5gM7O.png"><img src="http://i.imgur.com/RV5gM7Ol.png" alt="Prometheus alerts for DreamHack"></a>
</p><center><em>Oops! Turns out we have some bad uplinks, better run out and fix
it!</em></center>

<h2 id="being-proactive:-dashboards">Being proactive: dashboards<a class="header-anchor" href="#being-proactive-dashboards" name="being-proactive-dashboards"></a>
</h2>

<p>While alerting is an essential part of
monitoring, sometimes you just want to have a good overview of the health of
your network. To achieve this we used <a href="/docs/visualization/promdash/">PromDash</a>.
Every time someone asked us something about the network, we crafted a query to
get the answer and saved it as a dashboard widget. The most interesting ones
were then added to an overview dashboard that we proudly displayed.</p>

<p><a href="http://i.imgur.com/yYtC8vL.png"><img src="http://i.imgur.com/yYtC8vLl.png" alt="dhmon Dashboard"></a>
</p><center><em>The DreamHack Overview dashboard powered by PromDash</em></center>

<h2 id="the-future">The future<a class="header-anchor" href="#the-future" name="the-future"></a>
</h2>

<p>While changing an integral part of any system is a complex job and
we're happy that we managed to integrate Prometheus in just one event, there are
without a doubt a lot of areas to improve. Some areas are pretty basic: using
more precomputed metrics to improve performance, adding more alerts, and tuning
the ones we have. Another area is to make it easier for operators: creating an
alert dashboard suitable for our network operations center (NOC), figuring out
if we want to page the people on-call, or just let the NOC escalate alerts.</p>

<p>Some bigger features we're planning on adding: syslog analysis (we have a lot of
syslog!), alerts from our intrusion detection systems, integrating with our
Puppet setup, and also integrating more across the different teams at DreamHack.
We managed to create a proof-of-concept where we got data from one of the
electrical current sensors into our monitoring, making it easy to see if a
device is faulty or if it simply doesn't have any electricity anymore. We're
also working on integrating with the point-of-sale systems that are used in the
stores at the event. Who doesn't want to graph the sales of ice cream?</p>

<p>Finally, not all services that the team operates are on-site, and some even run
24/7 after the event. We want to monitor these services with Prometheus as well,
and in the long run when Prometheus gets support for federation, utilize the
off-site Prometheus to replicate the metrics from the event Prometheus.</p>

<h2 id="closing-words">Closing words<a class="header-anchor" href="#closing-words" name="closing-words"></a>
</h2>

<p>We're really excited about Prometheus and how easy it makes
setting up scalable monitoring and alerting from scratch.</p>

<p>A huge shout-out to everyone that helped us in <code>#prometheus</code> on
<a href="https://freenode.net/">FreeNode</a> during the event. Special thanks to Brian
Brazil, Fabian Reinartz and Julius Volz. Thanks for helping us even in the cases
where it was obvious that we hadn't read the documentation thoroughly enough.</p>

<p>Finally, dhmon is all open-source, so head over to <a href="https://github.com/dhtech/">https://github.com/dhtech/</a>
and have a look if you're interested. If you feel like you would like to be a
part of this, just head over to <code>#dreamhack</code> on
<a href="https://www.quakenet.org/">QuakeNet</a> and have a chat with us. Who knows, maybe
you will help us build the next DreamHack?</p>

      </article>
    </div>
  
    <div class="blog doc-content">
      <h1><a href="/blog/2015/06/18/practical-anomaly-detection/">Practical Anomaly Detection</a></h1>
      <aside>Posted at: June 18, 2015 by Brian Brazil</aside>
      <article class="doc-content">
        <p>In his <em><a href="http://www.kitchensoap.com/2015/05/01/openlettertomonitoringproducts/">Open Letter To Monitoring/Metrics/Alerting Companies</a></em>,
John Allspaw asserts that attempting "to detect anomalies perfectly, at the right time, is not possible".</p>

<p>I have seen several attempts by talented engineers to build systems to
automatically detect and diagnose problems based on time series data. While it
is certainly possible to get a demonstration working, the data always turned
out to be too noisy to make this approach work for anything but the simplest of
real-world systems.</p>

<p>All hope is not lost though. There are many common anomalies which you can
detect and handle with custom-built rules. The Prometheus <a href="../../../../../docs/querying/basics/">query
language</a> gives you the tools to discover
these anomalies while avoiding false positives.</p>

<h2 id="building-a-query">Building a query<a class="header-anchor" href="#building-a-query" name="building-a-query"></a>
</h2>

<p>A common problem within a service is when a small number of servers are not
performing as well as the rest, such as responding with increased latency.</p>

<p>Let us say that we have a metric <code>instance:latency_seconds:mean5m</code> representing the
average query latency for each instance of a service, calculated via a
<a href="/docs/querying/rules/">recording rule</a> from a
<a href="/docs/concepts/metric_types/#summary">Summary</a> metric.</p>

<p>A simple way to start would be to look for instances with a latency
more than two standard deviations above the mean:</p>

<pre><code>  instance:latency_seconds:mean5m
&gt; on (job) group_left(instance)
  (
      avg by (job)(instance:latency_seconds:mean5m)
    + on (job)
      2 * stddev by (job)(instance:latency_seconds:mean5m)
  )
</code></pre>

<p>You try this out and discover that there are false positives when
the latencies are very tightly clustered. So you add a requirement
that the instance latency also has to be 20% above the average:</p>

<pre><code>  (
      instance:latency_seconds:mean5m
    &gt; on (job) group_left(instance)
      (
          avg by (job)(instance:latency_seconds:mean5m)
        + on (job)
          2 * stddev by (job)(instance:latency_seconds:mean5m)
      )
  )
&gt; on (job) group_left(instance)
  1.2 * avg by (job)(instance:latency_seconds:mean5m)
</code></pre>

<p>Finally, you find that false positives tend to happen at low traffic levels.
You add a requirement for there to be enough traffic for 1 query per second to
be going to each instance. You create an alert definition for all of this:</p>

<pre><code>ALERT InstanceLatencyOutlier
  IF
        (
            instance:latency_seconds:mean5m
          &gt; on (job) group_left(instance)
            (
                avg by (job)(instance:latency_seconds:mean5m)
              + on (job)
                2 * stddev by (job)(instance:latency_seconds:mean5m)
            )
        )
      &gt; on (job) group_left(instance)
        1.2 * avg by (job)(instance:latency_seconds:mean5m)
    and on (job)
        avg by (job)(instance:latency_seconds_count:rate5m)
      &gt;
        1
  FOR 30m
  SUMMARY "{{$labels.instance}} in {{$labels.job}} is a latency outlier"
  DESCRIPTION "{{$labels.instance}} has latency of {{humanizeDuration $value}}"
</code></pre>

<h2 id="automatic-actions">Automatic actions<a class="header-anchor" href="#automatic-actions" name="automatic-actions"></a>
</h2>

<p>The above alert can feed into the
<a href="/docs/alerting/alertmanager/">Alertmanager</a>, and from there to
your chat, ticketing, or paging systems. After a while you might discover that the
usual cause of the alert is something that there is not a proper fix for, but there is an
automated action such as a restart, reboot, or machine replacement that resolves
the issue.</p>

<p>Rather than having humans handle this repetitive task, one option is to
get the Alertmanager to send the alert to a web service that will perform
the action with appropriate throttling and safety features.</p>

<p>The <a href="/docs/alerting/alertmanager/#generic-webhook">generic webhook</a>
sends alert notifications to an HTTP endpoint of your choice. A simple Alertmanager
configuration that uses it could look like this:</p>

<pre><code># A simple notification configuration which only sends alert notifications to
# an external webhook.
notification_config {
  name: "restart_webhook"
  webhook_config {
    url: "http://example.org/my/hook"
  }
}

# An aggregation rule which matches all alerts with the label
# alertname="InstanceLatencyOutlier" and sends them using the "restart_webhook"
# notification configuration.
aggregation_rule {
  filter {
    name_re: "alertname"
    value_re: "InstanceLatencyOutlier"
  }
  notification_config_name: "restart_webhook"
}
</code></pre>

<h2 id="summary">Summary<a class="header-anchor" href="#summary" name="summary"></a>
</h2>

<p>The Prometheus query language allows for rich processing of your monitoring
data. This lets you to create alerts with good signal-to-noise ratios, and the
Alertmanager's generic webhook support can trigger automatic remediations.
This all combines to enable oncall engineers to focus on problems where they can
have the most impact.</p>

<p>When defining alerts for your services, see also our <a href="http://prometheus.io/docs/practices/alerting/">alerting best practices</a>.</p>

      </article>
    </div>
  
    <div class="blog doc-content">
      <h1><a href="/blog/2015/06/01/advanced-service-discovery/">Advanced Service Discovery in Prometheus 0.14.0</a></h1>
      <aside>Posted at: June 1, 2015 by Fabian Reinartz, Julius Volz</aside>
      <article class="doc-content">
        <p>This week we released Prometheus v0.14.0 — a version with many long-awaited additions
and improvements.</p>

<p>On the user side, Prometheus now supports new service discovery mechanisms. In
addition to DNS-SRV records, it now supports <a href="https://www.consul.io">Consul</a>
out of the box, and a file-based interface allows you to connect your own
discovery mechanisms. Over time, we plan to add other common service discovery
mechanisms to Prometheus.</p>

<p>Aside from many smaller fixes and improvements, you can now also reload your configuration during
runtime by sending a <code>SIGHUP</code> to the Prometheus process. For a full list of changes, check the
<a href="https://github.com/prometheus/prometheus/blob/master/CHANGELOG.md#0140--2015-06-01">changelog for this release</a>.</p>

<p>In this blog post, we will take a closer look at the built-in service discovery mechanisms and provide
some practical examples. As an additional resource, see
<a href="/docs/operating/configuration">Prometheus's configuration documentation</a>.</p>

<h2 id="prometheus-and-targets">Prometheus and targets<a class="header-anchor" href="#prometheus-and-targets" name="prometheus-and-targets"></a>
</h2>

<p>For a proper understanding of this blog post, we first need to take a look at how
Prometheus labels targets.</p>

<p>There are various places in the configuration file where target labels may be
set. They are applied in the following order, with later stages overwriting any
labels set by an earlier stage:</p>

<ol>
<li>Global labels, which are assigned to every target scraped by the Prometheus instance.</li>
<li>The <code>job</code> label, which is configured as a default value for each scrape configuration.</li>
<li>Labels that are set per target group within a scrape configuration.</li>
<li>Advanced label manipulation via <a href="/docs/operating/configuration/#target-relabeling-relabel_config"><em>relabeling</em></a>.</li>
</ol>

<p>Each stage overwrites any colliding labels from the earlier stages. Eventually, we have a flat
set of labels that describe a single target. Those labels are then attached to every time series that
is scraped from this target.</p>

<p>Note: Internally, even the address of a target is stored in a special
<code>__address__</code> label. This can be useful during advanced label manipulation
(relabeling), as we will see later. Labels starting with <code>__</code> do not appear in
the final time series.</p>

<h2 id="scrape-configurations-and-relabeling">Scrape configurations and relabeling<a class="header-anchor" href="#scrape-configurations-and-relabeling" name="scrape-configurations-and-relabeling"></a>
</h2>

<p>Aside from moving from an ASCII protocol buffer format to YAML, a fundamental change to
Prometheus's configuration is the change from per-job configurations to more generalized scrape
configurations. While the two are almost equivalent for simple setups, scrape configurations
allow for greater flexibility in more advanced use cases.</p>

<p>Each scrape configuration defines a job name which serves as a default value for the
<code>job</code> label. The <code>job</code> label can then be redefined for entire target groups or individual targets.
For example, we can define two target groups, each of which defines targets for one job.
To scrape them with the same parameters, we can configure them as follows:</p>

<pre><code>scrape_configs:
- job_name: 'overwritten-default'

  scrape_interval: 10s
  scrape_timeout:  5s

  target_groups:
  - targets: ['10.1.200.130:5051', '10.1.200.134:5051']
    labels:
      job: 'job1'

  - targets: ['10.1.200.130:6220', '10.1.200.134:6221']
    labels:
      job: 'job2'
</code></pre>

<p>Through a mechanism named <a href="http://prometheus.io/docs/operating/configuration/#target-relabeling-relabel_config"><em>relabeling</em></a>,
any label can be removed, created, or modified on a per-target level. This
enables fine-grained labeling that can also take into account metadata coming
from the service discovery. Relabeling is the last stage of label assignment
and overwrites any labels previously set.</p>

<p>Relabeling works as follows:</p>

<ul>
<li>A list of source labels is defined.</li>
<li>For each target, the values of those labels are concatenated with a separator.</li>
<li>A regular expression is matched against the resulting string.</li>
<li>A new value based on those matches is assigned to another label.</li>
</ul>

<p>Mutiple relabeling rules can be defined for each scrape configuration. A simple one
that squashes two labels into one, looks as follows:</p>

<pre><code>relabel_configs:
- source_labels: ['label_a', 'label_b']
  separator:     ';'
  regex:         '(.*);(.*)'
  replacement:   '${1}-${2}'
  target_label:  'label_c'
</code></pre>

<p>This rule transforms a target with the label set:</p>

<pre><code>{
  "job": "job1",
  "label_a": "foo",
  "label_b": "bar"
}
</code></pre>

<p>...into a target with the label set:</p>

<pre><code>{
  "job": "job1",
  "label_a": "foo",
  "label_b": "bar",
  "label_c": "foo-bar"
}
</code></pre>

<p>You could then also remove the source labels in an additional relabeling step.</p>

<p>You can read more about relabeling and how you can use it to filter targets in the
<a href="/docs/operating/configuration#target-relabeling-relabel_config">configuration documentation</a>.</p>

<p>Over the next sections, we will see how you can leverage relabeling when using service discovery.</p>

<h2 id="discovery-with-dns-srv-records">Discovery with DNS-SRV records<a class="header-anchor" href="#discovery-with-dns-srv-records" name="discovery-with-dns-srv-records"></a>
</h2>

<p>Since the beginning, Prometheus has supported target discovery via DNS-SRV records.
The respective configuration looked like this:</p>

<pre><code>job {
  name: "api-server"
  sd_name: "telemetry.eu-west.api.srv.example.org"
  metrics_path: "/metrics"
}
</code></pre>

<p>Prometheus 0.14.0 allows you to specify multiple SRV records to be queried in a
single scrape configuration, and also provides service-discovery-specific meta
information that is helpful during the relabeling phase.</p>

<p>When querying the the DNS-SRV records, a label named <code>__meta_dns_srv_name</code> is
attached to each target. Its value is set to the SRV record name for which it was
returned. If we have structured SRV record names like <code>telemetry.&lt;zone&gt;.&lt;job&gt;.srv.example.org</code>,
we can extract relevant labels from it those names:</p>

<pre><code>scrape_configs:
- job_name: 'myjob'

  dns_sd_configs:
  - names:
    - 'telemetry.eu-west.api.srv.example.org'
    - 'telemetry.us-west.api.srv.example.org'
    - 'telemetry.eu-west.auth.srv.example.org'
    - 'telemetry.us-east.auth.srv.example.org'

  relabel_configs:
  - source_labels: ['__meta_dns_srv_name']
    regex:         'telemetry\.(.+?)\..+?\.srv\.example\.org'
    target_label:  'zone'
    replacement:   '$1'
  - source_labels: ['__meta_dns_srv_name']
    regex:         'telemetry\..+?\.(.+?)\.srv\.example\.org'
    target_label:  'job'
    replacement:   '$1'
</code></pre>

<p>This will attach the <code>zone</code> and <code>job</code> label to each target based on the SRV record
it came from.</p>

<h2 id="discovery-with-consul">Discovery with Consul<a class="header-anchor" href="#discovery-with-consul" name="discovery-with-consul"></a>
</h2>

<p>Service discovery via Consul is now supported natively. It can be configured by defining
access parameters for our Consul agent and a list of Consul services for which we want
to query targets.</p>

<p>The tags of each Consul node are concatenated by a configurable separator and exposed
through the <code>__meta_consul_tags</code> label. Various other Consul-specific meta
labels are also provided.</p>

<p>Scraping all instances for a list of given services can be achieved with a simple
<code>consul_sd_config</code> and relabeling rules:</p>

<pre><code>scrape_configs:
- job_name: 'overwritten-default'

  consul_sd_configs:
  - server:   '127.0.0.1:5361'
    services: ['auth', 'api', 'load-balancer', 'postgres']

  relabel_configs:
  - source_labels: ['__meta_consul_service']
    regex:         '(.*)'
    target_label:  'job'
    replacement:   '$1'
  - source_labels: ['__meta_consul_node']
    regex:         '(.*)'
    target_label:  'instance'
    replacement:   '$1'
  - source_labels: ['__meta_consul_tags']
    regex:         ',(production|canary),'
    target_label:  'group'
    replacement:   '$1'
</code></pre>

<p>This discovers the given services from the local Consul agent.
As a result, we get metrics for four jobs (<code>auth</code>, <code>api</code>, <code>load-balancer</code>, and <code>postgres</code>). If a node
has the <code>production</code> or <code>canary</code> Consul tag, a respective <code>group</code> label is assigned to the target.
Each target's <code>instance</code> label is set to the node name provided by Consul.</p>

<p>A full documentation of all configuration parameters for service discovery via Consul
can be found on the <a href="/docs/operating/configuration#target-relabeling-relabel_config">Prometheus website</a>.</p>

<h2 id="custom-service-discovery">Custom service discovery<a class="header-anchor" href="#custom-service-discovery" name="custom-service-discovery"></a>
</h2>

<p>Finally, we added a file-based interface to integrate your custom service discovery or other common mechanisms
that are not yet supported out of the box.</p>

<p>With this mechanism, Prometheus watches a set of directories or files which define target groups.
Whenever any of those files changes, a list of target groups is read from the files and scrape targets
are extracted.
It's now our job to write a small bridge program that runs as Prometheus's side-kick.
It retrieves changes from an arbitrary service discovery mechanism and writes the target information
to the watched files as lists of target groups.</p>

<p>These files can either be in YAML:</p>

<pre><code>- targets: ['10.11.150.1:7870', '10.11.150.4:7870']
  labels:
    job: 'mysql'

- targets: ['10.11.122.11:6001', '10.11.122.15:6002']
  labels:
    job: 'postgres'
</code></pre>

<p>...or in JSON format:</p>

<pre><code>[
  {
    "targets": ["10.11.150.1:7870", "10.11.150.4:7870"],
    "labels": {
      "job": "mysql"
    }
  },
  {
    "targets": ["10.11.122.11:6001", "10.11.122.15:6002"],
    "labels": {
      "job": "postgres"
    }
  }
]
</code></pre>

<p>We now configure Prometheus to watch the <code>tgroups/</code> directory in its working directory
for all <code>.json</code> files:</p>

<pre><code>scrape_configs:
- job_name: 'overwritten-default'

  file_sd_configs:
  - names: ['tgroups/*.json']
</code></pre>

<p>What's missing now is a program that writes files to this directory. For the sake of this example,
let's assume we have all our instances for different jobs in a single denormalized MySQL table.
(Hint: you probably don't want to do service discovery this way.)</p>

<p>Every 30 seconds, we read all instances from the MySQL table and write the
resulting target groups into a JSON file. Note that we do not have to keep
state whether or not any targets or their labels have changed. Prometheus will
automatically detect changes and applies them to targets without interrupting
their scrape cycles.</p>

<pre><code>import os, time, json

from itertools import groupby
from MySQLdb import connect


def refresh(cur):
    # Fetch all rows.
    cur.execute("SELECT address, job, zone FROM instances")

    tgs = []
    # Group all instances by their job and zone values.
    for key, vals in groupby(cur.fetchall(), key=lambda r: (r[1], r[2])):
        tgs.append({
            'labels': dict(zip(['job', 'zone'], key)),
            'targets': [t[0] for t in vals],
        })

    # Persist the target groups to disk as JSON file.
    with open('tgroups/target_groups.json.new', 'w') as f:
        json.dump(tgs, f)
        f.flush()
        os.fsync(f.fileno())

    os.rename('tgroups/target_groups.json.new', 'tgroups/target_groups.json')


if __name__ == '__main__':
    while True:
        with connect('localhost', 'root', '', 'test') as cur:
            refresh(cur)
        time.sleep(30)
</code></pre>

<p>While Prometheus will not apply any malformed changes to files, it is considered best practice to
update your files atomically via renaming, as we do in our example.
It is also recommended to split larger amounts of target groups into several files based on
logical grouping.</p>

<h2 id="conclusion">Conclusion<a class="header-anchor" href="#conclusion" name="conclusion"></a>
</h2>

<p>With DNS-SRV records and Consul, two major service discovery methods are now
natively supported by Prometheus. We've seen that relabeling is a powerful
approach to make use of metadata provided by service discovery mechanisms.</p>

<p>Make sure to take a look at the new <a href="/docs/operating/configuration/">configuration documentation</a>
to upgrade your Prometheus setup to the new release and find out about other configuration options,
such as basic HTTP authentication and target filtering via relabeling.</p>

<p>We provide a <a href="https://github.com/prometheus/migrate/releases">migration tool</a> that upgrades
your existing configuration files to the new YAML format.
For smaller configurations we recommend a manual upgrade to get familiar with the new format and
to preserve comments.</p>

      </article>
    </div>
  
    <div class="blog doc-content">
      <h1><a href="/blog/2015/04/24/prometheus-monitring-spreads-through-the-internet/">Prometheus Monitoring Spreads through the Internet</a></h1>
      <aside>Posted at: April 24, 2015 by Brian Brazil</aside>
      <article class="doc-content">
        <p>It has been almost three months since we publicy announced Prometheus version
0.10.0, and we're now at version 0.13.1.</p>

<p><a href="https://developers.soundcloud.com/blog/prometheus-monitoring-at-soundcloud">SoundCloud's announcement blog post</a>
remains the best overview of the key components of Prometheus, but there has
been a lot of other online activity around Prometheus. This post will let you
catch up on anything you missed.</p>

<p>In the future, we will use this blog to publish more articles and announcements
to help you get the most out of Prometheus.</p>

<h2 id="using-prometheus">Using Prometheus<a class="header-anchor" href="#using-prometheus" name="using-prometheus"></a>
</h2>

<p>Posts on how to use Prometheus comprise the majority of online content. Here
are the ones we're aware of with the part of the ecosystem they cover:</p>

<ul>
<li>Container Exporter: <a href="https://5pi.de/2015/01/26/monitor-docker-containers-with-prometheus/">Monitor Docker Containers with Prometheus</a>
</li>
<li>HAProxy: <a href="http://www.boxever.com/haproxy-monitoring-with-prometheus">HAProxy Monitoring with Prometheus</a>
</li>
<li>Java Client: <a href="http://www.boxever.com/easy-java-instrumentation-with-prometheus">Easy Java Instrumentation with Prometheus</a>
</li>
<li>Java Client and Labels: <a href="http://www.boxever.com/the-power-of-multi-dimensional-labels-in-prometheus">The Power of Multi-Dimensional Labels in Prometheus</a>
</li>
<li>Node Exporter: <a href="http://www.boxever.com/monitoring-your-machines-with-prometheus">Monitoring your Machines with Prometheus</a>
</li>
<li>JMX Exporter: <a href="http://www.boxever.com/cassandra-consoles-with-jmx-and-prometheus">Cassandra Consoles with JMX and Prometheus</a>
</li>
<li>Python Client and Node Exporter Textfile Collector: <a href="http://www.boxever.com/monitoring-python-batch-jobs">Monitoring Python Batch Jobs</a>
</li>
<li>Mesos Exporter: <a href="http://www.antonlindstrom.com/2015/02/24/monitoring-mesos-tasks-with-prometheus.html">Monitoring Mesos tasks with Prometheus</a>
</li>
<li>Synapse: <a href="http://matrix.org/blog/2015/04/23/monitoring-synapse-metrics-with-prometheus/">Monitoring Synapse Metrics with Prometheus</a>
</li>
</ul>

<h2 id="articles">Articles<a class="header-anchor" href="#articles" name="articles"></a>
</h2>

<p>These articles look at how Prometheus fits into the broader picture of keeping services up and running:</p>

<ul>
<li><a href="http://www.boxever.com/prometheus-a-next-generation-monitoring-system">Prometheus: A Next-Generation Monitoring System</a></li>
<li><a href="http://thenewstack.io/soundclouds-prometheus-monitoring-system-time-series-database-suited-containers/">SoundCloud’s Prometheus: A Monitoring System and Time Series Database Suited for Containers</a></li>
<li><a href="http://rancher.com/docker-monitoring-continued-prometheus-and-sysdig/">Docker Monitoring Continued: Prometheus and Sysdig</a></li>
</ul>

<h2 id="philosophy">Philosophy<a class="header-anchor" href="#philosophy" name="philosophy"></a>
</h2>

<p>Monitoring isn't just about the technical details. How it affects the design of
your systems, operations, and human factors are important too:</p>

<ul>
<li><a href="http://www.boxever.com/push-vs-pull-for-monitoring">Push vs Pull for Monitoring</a></li>
<li><a href="http://www.slideshare.net/brianbrazil/devops-ireland-systems-monitoring-with-prometheus">Systems Monitoring with Prometheus</a></li>
<li><a href="http://www.slideshare.net/brianbrazil/python-ireland-monitoring-your-python-with-prometheus">Monitoring your Python with Prometheus</a></li>
</ul>

<p>The comments on the <a href="https://news.ycombinator.com/item?id=8995696">Hacker News post</a> about Prometheus are also insightful.</p>

<h2 id="non-english">Non-English<a class="header-anchor" href="#non-english" name="non-english"></a>
</h2>

<p>Several posts have appeared in languages beyond English:</p>

<ul>
<li>Japanese how-to about installing Prometheus on CentOS: <a href="http://y-ken.hatenablog.com/entry/how-to-install-prometheus">データ可視化アプリの新星、PrometheusをCentOSにインストールする方法</a>
</li>
<li>Japanese in-depth tutorial: <a href="http://pocketstudio.jp/log3/2015/02/11/what_is_prometheus_monitoring/">【入門】PrometheusでサーバやDockerコンテナのリソース監視</a>
</li>
<li>Japanese overview: <a href="http://wazanova.jp/items/1672">Prometheus: Go言語で書かれたモニタリングシステム</a>
</li>
<li>Russian podcast that mentions Prometheus: <a href="http://www.rwpod.com/posts/2015/02/02/podcast-03-04.html">RWPOD 04 выпуск 03 сезона</a>
</li>
</ul>

<h2 id="closing">Closing<a class="header-anchor" href="#closing" name="closing"></a>
</h2>

<p>Finally, I'd like to share how to run <a href="https://5pi.de/2015/02/10/prometheus-on-raspberry-pi/">Prometheus on a Raspberry Pi</a>.</p>

      </article>
    </div>
  
</div>
<div class="col-md-3 side-nav-col">
  <ul class="nav navbar-nav side-nav">
    <li>
      <span class="nav-header">Blog posts</span>
      <ul class="nav">
      
        <li><a href="/blog/2015/08/17/service-discovery-with-etcd/">Custom service discovery with etcd</a></li>
      
        <li><a href="/blog/2015/06/24/monitoring-dreamhack/">Monitoring DreamHack - the World's Largest Digital Festival</a></li>
      
        <li><a href="/blog/2015/06/18/practical-anomaly-detection/">Practical Anomaly Detection</a></li>
      
        <li><a href="/blog/2015/06/01/advanced-service-discovery/">Advanced Service Discovery in Prometheus 0.14.0</a></li>
      
        <li><a href="/blog/2015/04/24/prometheus-monitring-spreads-through-the-internet/">Prometheus Monitoring Spreads through the Internet</a></li>
      
    </ul>
  </ul>
</div>


</div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/assets/bootstrap-3.3.1/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="/assets/ie10-viewport-bug-workaround.js"></script>
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-58468480-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>

